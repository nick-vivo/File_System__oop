#ifndef __STRING_HPP__
#include "../string.hpp"

namespace my
{

size_t strlen(const char *const str)
{
    size_t count = 0;
    while(*(str + count) != '\0')
        ++count;
    return count;
}

my::string operator+(const char *const str_2, const my::string &str_1) noexcept
{
    my::size_t length_2 = my::strlen(str_2);
    my::string sum;
    sum._length = length_2 + str_1._length;
    
    while(sum._capacity < sum._length + 1)
        sum._capacity += _STEP_STRING;
    
    sum._data = new char[sum._capacity];
    
    my::size_t i = 0;
    for( ;i < length_2; ++i)
        sum._data[i] = str_2[i];

    for(size_t j = 0; i < sum._length; ++i, ++j)
        sum._data[i] = str_1[j];
    sum._data[sum._length] = '\0';
    
    return sum;
}

std::ostream& operator<<(std::ostream &stream, const my::string& str)
{
    return stream << str.c_str();
}

std::istream& operator>>(std::istream &stream, my::string& str)
{
    char na[255];
    stream >> na;
    str = na;
    return stream;
}

my::string operator+( const my::string& str_1, const char* const str_2) noexcept
{
    my::size_t length_2 = my::strlen(str_2);
    my::string sum;
    sum._length = length_2 + str_1._length;
    
    while(sum._capacity < sum._length + 1)
        sum._capacity += _STEP_STRING;
    
    sum._data = new char[sum._capacity];

    my::size_t i = 0;
    for( ;i < str_1._length; ++i)
        sum._data[i] = str_1[i];

    for(size_t j = 0 ;i < sum._length; ++i, ++j)
        sum._data[i] = str_2[j];
    sum._data[sum._length] = '\0';
    
    return sum;
}

string::string() : _capacity(0), _length(0), _data(nullptr) {}

string::string(const char* const str): _capacity(0), _length(strlen(str)), _data(nullptr)
{
    while(this->_capacity < this->_length + 1)
        this->_capacity += _STEP_STRING;
    this->_data = new char[this->_capacity];

    for(size_t i = 0; i < this->_length; ++i)
        this->_data[i] = str[i];
    this->_data[this->_length] = '\0';
}

string::string(const string& other): _capacity(other._capacity), _length(other._length)
{
    this->_data = new char[this->_capacity];
    for(size_t i = 0; i < this->_length; ++i)
        this->_data[i] = other._data[i];
    this->_data[this->_length] = '\0';
}

string::string(string&& other): _capacity(other._capacity), _length(other._length), _data(other._data)
{
    other._capacity = 0;
    other._length = 0;
    other._data = nullptr;
}

string::~string()
{
    if(this->_data)
    {
        delete[] this->_data;
        this->_data = nullptr;
    }
}

inline char& string::operator[](const size_t index) const noexcept
{
    return *(this->_data + index);
}

string &string::operator=(const string &other) noexcept
{
    this->_length = other._length;
    if (this->_capacity < this->_length + 1)
    {
        this->~string();
        while (this->_capacity < this->_length + 1)
            this->_capacity += _STEP_STRING;
        this->_data = new char[this->_capacity];
    }

    for (size_t i = 0; i < this->_length; ++i)
        this->_data[i] = other._data[i];
    this->_data[this->_length] = '\0';
    return *this;
}

string &string::operator=(const char *const str) noexcept
{
    this->_length = strlen(str);
    if (this->_capacity < this->_length + 1)
    {
        this->~string();
        while (this->_capacity < this->_length + 1)
            this->_capacity += _STEP_STRING;
        this->_data = new char[this->_capacity];
    }

    for (size_t i = 0; i < this->_length; ++i)
        this->_data[i] = str[i];
    this->_data[this->_length] = '\0';
    return *this;
}

void string::operator=(string &&other) noexcept
{
    delete[] this->_data;
    this->_data = other._data;
    this->_capacity = other._capacity;
    this->_length = other._length;

    other._capacity = 0;
    other._length = 0;
    other._data = nullptr;
}

string string::operator+(const string &other) const noexcept
{
    string sum;
    sum._length = this->_length + other._length;
    while (sum._capacity < sum._length + 1)
        sum._capacity += _STEP_STRING;
    sum._data = new char[sum._capacity];

    size_t i = 0;
    for (; i < this->_length; ++i)
        sum._data[i] = this->_data[i];
    for (size_t j = 0; i < sum._length; ++i, ++j)
        sum._data[i] = other._data[j];
    sum._data[sum._length] = '\0';

    return sum;
}

string &string::operator+=(const string &other) noexcept
{
    *this = *this + other;
    return *this;
}

string &string::operator+=(const char *const str) noexcept
{
    *this = *this + str;
    return *this;
}

bool string::operator!=(const char* const other) const noexcept
{
    return !this->operator==(other);
}

bool string::operator!=(const string& other) const noexcept
{
    return !this->operator==(other);
}

bool string::operator==(const char *const other) const noexcept
{
    size_t length = strlen(other);
    if(this->_length != length)
        return false;
    for(size_t i = 0; i < length; ++i)
    {
        if(this->_data[i] != other[i])
            return false;
    }
    return true;
}

bool string::operator==(const string& other) const noexcept
{
    if(this->_length != other._length)
        return false;
    for(size_t i = 0; i < this->_length; ++i)
    {
        if(this->_data[i] != other._data[i])
            return false;
    }
    return true;
}


//1,2.Выписывает размер строки
inline size_t string::size() const noexcept
{
    return this->_length;
}

//3.Проверяет пуста ли строка (_length == 0)
inline bool string::empty() const noexcept
{
    if (this->_length == 0)
        return true;
    return false;
}

//4.Делает строку пустой, но размер в динамической памяти остается таким же(все заменяется на '\0')
inline void string::clear() const noexcept
{
    for (size_t i = 0; i < this->_length; ++i)
        this->_data[i] = '\0';
}

//13. Возвращает указатель на массив символов, представляющий строку
inline char const *string::c_str() const noexcept
{
    return this->_data;
}

//14.Бросает исключение если index выходит за пределы
inline char &string::at(size_t index) noexcept(false)
{
    if (index < 0 || index >= this->_length)
        throw "going beyond";
    return *(this->_data + index);
}
//capacity
size_t string::capacity()
{
    return this->capacity() * sizeof(char);
}
//Бета версия ресерва, закидывают исключение
void string::reserve(size_t new_capacity) noexcept(false)
{
    if ((new_capacity < this->_capacity) && (new_capacity < (this->_length + 1)))
    {
        throw "data miss";
    }
    else if (new_capacity != this->_capacity)
    {
        string cp(*this);
        this->~string();
        this->_capacity = new_capacity;
        this->_data = new char[new_capacity];
        *this = cp;
    }
}
//Бета версия резайса, закидывают исключение
void string::resize(size_t new_size) noexcept(false)
{
    if (new_size < this->_length)
    {
        throw "data miss";
    }
    else if (new_size > this->_length)
    {
        if (new_size + 1 > this->_capacity)
        {
            while (new_size + 1 > this->_capacity)
                this->_capacity += _STEP_STRING;
            this->_data = new char[this->_capacity];
        }
        for (size_t i = this->_length; i < new_size; ++i)
        {
            this->_data[i] = 'c';
        }
        this->_length = new_size;
        this->_data[this->_length] = '\0';
    }
}
//swap переделать, когда будет время
void string::swap(string &other) noexcept(false)
{
    string cp(*this);
    *this = other;
    other = cp;
}
};
#endif
