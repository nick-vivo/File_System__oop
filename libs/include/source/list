#ifndef __LIST_HPP__
#include "../list.hpp"

template<typename T>
my::list<T>::~list()
{
    while(this->_head != nullptr)
        this->pop_front();
}

template<typename T>
void my::list<T>::push_back(T data) noexcept
{
    if (this->_head == nullptr)
    {
        this->_head = new node<T>(data);
    }
    else
    {
        node<T> *current = this->_head;
        while(current->_pNext != nullptr)
            current = current->_pNext;
        current->_pNext = new node<T>(data);
    }
    ++this->_size;
}

template<typename T>
inline T& my::list<T>::operator[](const type_s index) noexcept
{
    if(index >= this->_size || index < 0)
    {
        throw my::exception("Bad index");
    }
    type_s count = 0;
    node<T>* current = this->_head;

    while(count != index)
    {
        current = current->_pNext;
        ++count;
    }
    return current->_data;
}

template<typename T>
void my::list<T>::pop_front()
{
    if(this->_head != nullptr)
    {
        node<T>* current = this->_head;
        this->_head = this->_head->_pNext;
        delete current;
        --this->_size;
    }
    else
    {
        throw my::exception("Size is 0, HEAD = nullptr");
    }

}

template<typename T>
void my::list<T>::push_front(T data)
{
    this->_head = new node<T>(data, this->_head);
    ++this->_size;
}

template<typename T>
void my::list<T>::insert(T data, my::type_s index)
{
    if (index == 0)
    {
        this->push_front(data);
    }
    else if( index > 0 && index <= this->_size)
    {
        node<T>* previous = this->_head;
        for(my::type_s i = 0; i < index - 1; ++i)
        {
            previous = previous->_pNext;
        }
        node<T>* newNode = new node<T>(data, previous->_pNext);
        previous->_pNext = newNode;
        ++this->_size;
    }
    else
    {
        throw my::exception("Fail index");
    }
}

template<typename T>
void my::list<T>::removeAt( my::type_s index )
{   
    if (index == 0)
    {
        this->pop_front();
    }
    else if(index > 0 && index < this->_size)
    {
        node<T>* previous = this->_head;
        for(type_s i = 0; i < index - 1; ++i)
        {
            previous = previous->_pNext;
        }
        node<T>* to_Delete = previous->_pNext;

        previous->_pNext = to_Delete->_pNext;
        --this->_size;
        delete to_Delete;
    }
    else
    {
        throw my::exception("Fail index");
    }
}



#endif